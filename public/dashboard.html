<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Finance Metrics Dashboard</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    :root{
      --bg:#f4f6f9;
      --card:#ffffff;
      --muted:#6b7280;
      --accent:#0f766e;
      --tel: #2ca02c; /* green */
      --st:  #ff7f0e; /* orange */
      --dd:  #1f77b4; /* blue */
    }
    body{font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background:var(--bg); color:#071024; margin:0; padding:22px;}
    .container{max-width:1200px; margin:0 auto;}
    header{display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:18px;}
    h1{font-size:20px; margin:0;}
    .controls {display:flex; gap:12px; align-items:center;}
    .btn {
      display:inline-block; padding:8px 12px; background:var(--accent); color:#fff; border-radius:8px; text-decoration:none; font-weight:600; border:none; cursor:pointer;
    }
    .muted{color:var(--muted); font-size:13px;}
    .grid {
      display:grid;
      grid-template-columns: repeat(2, 1fr);
      gap:20px;
      margin-bottom:26px;
    }
    @media (max-width:880px){
      .grid { grid-template-columns: 1fr; }
    }
    .card {
      background:var(--card); border-radius:10px; padding:16px; box-shadow:0 6px 18px rgba(15,23,42,0.06);
      min-height: 360px;
      display:flex; flex-direction:column;
    }
    .card h3 { margin:0 0 8px; font-size:15px; }
    .canvas-wrap { flex:1; display:flex; align-items:center; justify-content:center; }
    canvas { width:100% !important; height: 300px !important; }
    .explainer { background:var(--card); border-radius:10px; padding:18px; box-shadow:0 6px 18px rgba(15,23,42,0.04); margin-top:20px; }
    .explainer h2 { margin-top:0; }
    pre { background:#0b1220; color:#dbeafe; padding:12px; border-radius:6px; overflow:auto; font-size:13px; }
    .status { display:flex; gap:12px; align-items:center; }
    .status .info { background:#f8fafc; padding:8px 10px; border-radius:8px; font-size:13px; color:#0f172a; }
    .no-data { color:var(--muted); text-align:center; padding:18px; }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Alpha Vantage Finance Metrics Dashboard</h1>
      <div class="controls">
        <button id="runLoadBtn" class="btn">Run / Load (ETL)</button>
        <div class="status" aria-live="polite">
          <div id="lastRunInfo" class="info">ETL last run: <span id="lastRunText">—</span></div>
        </div>
      </div>
    </header>

    <section class="grid" aria-label="metrics charts">
      <div class="card" id="card-netmargin">
        <h3>Net Margin (%)</h3>
        <div class="canvas-wrap">
          <canvas id="netMarginChart"></canvas>
        </div>
        <p class="muted" id="note-netmargin">Net income ÷ Revenue, shown as percent.</p>
      </div>

      <div class="card" id="card-currentratio">
        <h3>Current Ratio</h3>
        <div class="canvas-wrap">
          <canvas id="currentRatioChart"></canvas>
        </div>
        <p class="muted" id="note-currentratio">Approximation: total_assets ÷ total_liabilities.</p>
      </div>

      <div class="card" id="card-revenueyoy">
        <h3>Revenue YoY (%)</h3>
        <div class="canvas-wrap">
          <canvas id="revenueYoYChart"></canvas>
        </div>
        <p class="muted" id="note-revenueyoy">Year-over-year revenue growth.</p>
      </div>

      <div class="card" id="card-netincomeyoy">
        <h3>Net Income YoY (%)</h3>
        <div class="canvas-wrap">
          <canvas id="netIncomeYoYChart"></canvas>
        </div>
        <p class="muted" id="note-netincomeyoy">Year-over-year net income growth.</p>
      </div>
    </section>

    <!-- EXPLAINER -->
    <section class="explainer" aria-labelledby="explainer-heading">
      <h2 id="explainer-heading">Pipeline Productionization</h2>

      <div class="section">
        <h3>1. How would you schedule the code to run monthly?</h3>
        <p class="muted">Two robust choices are shown below: <strong>n8n</strong> (visual workflow orchestrator) and a <strong>cron job</strong> on a scheduler host. Use n8n when you want low-friction visual flows and integrations. Use cron for a lightweight, no-extra-service approach.</p>

        <h4>n8n recommended workflow (high-level)</h4>
        <pre>
[n8n Cron (monthly at 02:00 UTC on 1st day)]
        |
        v
[HTTP Request] -> GET https://your.api/load
        |
        v
[Conditional Node] -> if status=200 then
        -> [Slack/Email] notify success
        -> else -> [Retry logic / webhook to ops]
        </pre>

        <h4>cron pseudocode</h4>
        <pre>
# Run at 02:00 on the 1st of every month
0 2 1 * * /usr/bin/curl -fsS https://your.api/load >> /var/log/finance_etl.log 2>&1
# Check log and send alert if last run failed (via simple wrapper script)
        </pre>

        <p class="muted">Recommendation: Use n8n in production if you (a) need easy integrations (Sheets, Slack), (b) want retries/visual logs. Use Cron + systemd timers on a host only if you want minimal infra.</p>
      </div>

      <div class="section">
        <h3>2. How would you handle the API rate limit for 100 companies?</h3>
        <p class="muted">Alpha Vantage (free) limits are <strong>5 requests/minute</strong> and <strong>25 requests/day</strong> per key in your environment. For 100 companies, you must design a robust, incremental ingestion strategy.</p>

        <h4>Strategy summary</h4>
        <ul>
          <li><strong>Incremental & Prioritised Updates:</strong> Don’t fetch all historical data each run. Only fetch the most recent periods you care about (e.g., latest annual report). Cache historical results in Postgres.</li>
          <li><strong>Batching & Scheduling:</strong> Spread calls across multiple days. Example: 100 companies × 3 statements = 300 calls. At 25 calls/day per key you'd need 12 days with one free key; instead rotate keys or buy higher tier.</li>
          <li><strong>Key Rotation:</strong> Maintain multiple API keys (in env vars/secret store). Rotate keys on each request to distribute daily quota. Track usage per key.</li>
          <li><strong>Queue + Worker Model:</strong> Put company update jobs into a durable queue (Redis/RabbitMQ). Workers consume at the allowed rate, respecting per-key per-minute limits.</li>
          <li><strong>Fallback & Backfill:</strong> If live fetch fails, mark the company as stale and schedule backfill jobs during low-load windows.</li>
        </ul>

        <h4>Architecture sketch (text)</h4>
        <pre>
[Scheduler (n8n/cron)]
        |
        v
[Queue: jobs(company, statementType, priority)]
        |
        v
[Worker pool] --- uses ---> [API Key pool & rate limiter]
        |
        v
[PostgreSQL] (writes raw JSON + normalized rows)
        </pre>

        <h4>Example pseudocode for worker</h4>
        <pre>
while job = queue.pop():
  apiKey = keyPool.next()
  for attempt in 1..3:
    resp = fetchStatement(job.symbol, job.type, apiKey)
    if resp.Note or resp.Information:
      # rate limited or invalid -> re-enqueue with delay, rotate key
      keyPool.markKeyAsUsed(apiKey)
      sleep(12000) # per-minute spacing
      continue
    insertIntoDb(resp)
    break
  sleep(12000) # keep per-minute limit
        </pre>

        <h4>Capacity math</h4>
        <ul>
          <li>Needed calls = companies × statements_per_company (100 × 3 = 300 calls)</li>
          <li>If one key = 25/day → 12 days. With 4 keys → ~3 days. Paid tier or different provider recommended for production.</li>
        </ul>

      </div>

      <div class="section">
        <h3>3. How would execs access this data in Google Sheets?</h3>
        <p class="muted">Common options and tradeoffs:</p>

        <h4>Option A — Direct Postgres connection from Sheets</h4>
        <ul>
          <li><strong>Pros:</strong> Live data access.</li>
          <li><strong>Cons:</strong> Requires exposing DB (security risk), connection limits, and careful credential management. Not recommended for exec-facing dashboards unless protected via a query service.</li>
        </ul>

        <h4>Option B — Export CSV / Scheduled Sync</h4>
        <ul>
          <li><strong>Pros:</strong> Simple, safe. ETL writes CSV to secure storage (S3) or pushes to Google Drive. Execs open CSV in Sheets.</li>
          <li><strong>Cons:</strong> Not real-time (scheduled), but usually acceptable for monthly finance reports.</li>
        </ul>

        <h4>Option C — Use BigQuery (or a data warehouse) + Sheets connector</h4>
        <ul>
          <li><strong>Pros:</strong> Scalable, secure, Sheets can query BigQuery directly via the connector. Allows heavier analytics, joins, history retention.</li>
          <li><strong>Cons:</strong> More setup, cost, and data movement complexity.</li>
        </ul>

        <p class="muted"><strong>Recommendation:</strong> For monthly executive reporting, sync data to BigQuery (or managed analytics DB), then use the native Google Sheets connector to pull named queries/tables. This balances security, performance and usability.</p>
      </div>

      <div class="section">
        <h3>4. What breaks first, and monitoring/alerts to add?</h3>
        <p class="muted">Most likely failures and how to detect them:</p>
        <ul>
          <li><strong>API rate limits / 429s:</strong> detect API responses containing "Note" or 429 status. Alert on sustained rate-limited responses & failed daily job counts.</li>
          <li><strong>Network errors:</strong> retries with exponential backoff and alert if repeated failures exceed threshold.</li>
          <li><strong>Schema changes / missing fields:</strong> validate responses; if expected fields (e.g., totalRevenue) are missing or non-numeric, mark the company as 'bad data' and raise an alert.</li>
          <li><strong>DB insertion failures:</strong> monitor error rates and failed insert counts (e.g., duplicate key errors, connection refused).</li>
        </ul>

        <h4>Monitoring & alerts (practical list)</h4>
        <ul>
          <li>Metric: ETL run success/failure count (per run) → Alert if failed runs &gt; 0.</li>
          <li>Metric: API error rate (percentage of calls returning "Note"/429) → Alert at e.g. &gt; 5% sustained for 1 hour.</li>
          <li>Metric: Data freshness (last successful fetch per company) → Alert if older than X days.</li>
          <li>Metric: Row counts & sanity checks (expected rows vs actual) → Alert on mismatch.</li>
        </ul>

        <h4>Bad-data detection rules (suggested)</h4>
        <pre>
# examples
- Reject row if revenue is null or zero for 3 consecutive years (possible API failure)
- Reject row if fiscal_year > current_year or fiscal_year < 1990 (obvious nonsense)
- Reject if string fields appear where numbers are expected
- Maintain a `raw_responses` table to diff and re-run parsing
        </pre>

        <p class="muted">Push alerts to Slack/Email and surface an "ETL Status" panel in your dashboard showing last run timestamp, success, and per-company status.</p>
      </div>

      <div class="section">
        <h3>Deliverables & Deployment notes</h3>
        <ul>
          <li>Host Node app (API & dashboard) on Render/Heroku/VM. Run Postgres in Docker (or use managed DB like RDS/Cloud SQL).</li>
          <li>Use n8n or GitHub Actions to schedule the ETL trigger (n8n recommended for visual flows & retries).</li>
          <li>For scale and reliability: move raw API responses to object storage, index them in Postgres, and use a worker queue for controlled ingestion.</li>
        </ul>
      </div>
    </section>
  </div>


<script>
  // ---------- config ----------
  const COLORS = {
    TEL: getComputedStyle(document.documentElement).getPropertyValue('--tel').trim() || '#2ca02c',
    ST:  getComputedStyle(document.documentElement).getPropertyValue('--st').trim()  || '#ff7f0e',
    DD:  getComputedStyle(document.documentElement).getPropertyValue('--dd').trim()  || '#1f77b4'
  };

  // Chart instances
  let charts = {};

  // Helper: fetch metrics from /metrics
  async function fetchMetrics() {
    try {
      const res = await fetch('/metrics');
      if (!res.ok) throw new Error('Network response not ok');
      const data = await res.json();
      return Array.isArray(data) ? data : [];
    } catch (err) {
      console.error('Failed to fetch /metrics:', err);
      return [];
    }
  }

  // Transform metrics into labels + datasets
  function transformForMetric(rows, metricField) {
    const symbols = [...new Set(rows.map(r => r.symbol))].sort();
    const years = [...new Set(rows.map(r => r.fiscal_year))].sort((a,b)=>a-b);

    const datasets = symbols.map(sym => {
      const data = years.map(y => {
        const row = rows.find(r => r.symbol === sym && r.fiscal_year === y);
        if (!row) return null;
        const v = row[metricField];
        return v === null || v === undefined ? null : Number(v);
      });
      return {
        label: sym,
        data,
        borderColor: COLORS[sym] || '#888888',
        backgroundColor: COLORS[sym] || '#888888',
        fill: false,
        tension: 0.25,
        pointRadius: 4
      };
    });

    return { labels: years, datasets };
  }

  function createOrUpdateChart(canvasId, cfg) {
    const ctx = document.getElementById(canvasId).getContext('2d');
    if (charts[canvasId]) {
      charts[canvasId].data = cfg;
      charts[canvasId].update();
      return charts[canvasId];
    }
    const chart = new Chart(ctx, {
      type: 'line',
      data: cfg,
      options: {
        responsive: true,
        plugins: { legend: { position: 'top' } },
        scales: { y: { beginAtZero: false } }
      }
    });
    charts[canvasId] = chart;
    return chart;
  }

  // render all charts
  async function renderCharts() {
    const rows = await fetchMetrics();

    if (!rows || rows.length === 0) {
      ['netMarginChart','currentRatioChart','revenueYoYChart','netIncomeYoYChart'].forEach(id=>{
        if (charts[id]) { charts[id].destroy(); delete charts[id]; }
      });
      document.getElementById('note-netmargin').textContent = 'No data available — run ETL (click Run /load) or check /metrics.';
      document.getElementById('note-currentratio').textContent = 'No data available — run ETL (click Run /load) or check /metrics.';
      document.getElementById('note-revenueyoy').textContent = 'No data available — run ETL (click Run /load) or check /metrics.';
      document.getElementById('note-netincomeyoy').textContent = 'No data available — run ETL (click Run /load) or check /metrics.';
      return;
    }

    const netCfg = transformForMetric(rows, 'net_margin');
    const curCfg = transformForMetric(rows, 'current_ratio');
    const revCfg = transformForMetric(rows, 'revenue_yoy');
    const netYoYCfg = transformForMetric(rows, 'net_income_yoy');

    createOrUpdateChart('netMarginChart', netCfg);
    createOrUpdateChart('currentRatioChart', curCfg);
    createOrUpdateChart('revenueYoYChart', revCfg);
    createOrUpdateChart('netIncomeYoYChart', netYoYCfg);

    document.getElementById('note-netmargin').textContent = 'Net income ÷ Revenue, shown as percent.';
    document.getElementById('note-currentratio').textContent = 'Approximation: total_assets ÷ total_liabilities.';
    document.getElementById('note-revenueyoy').textContent = 'Year-over-year revenue growth.';
    document.getElementById('note-netincomeyoy').textContent = 'Year-over-year net income growth.';
  }

  // Fetch and display last ETL run
  async function updateLastETLRun() {
    try {
      const res = await fetch('/etl-last-run');
      if (!res.ok) throw new Error('Failed to fetch ETL last run');
      const data = await res.json();
      const lastRunText = data.lastRun
        ? new Date(data.lastRun).toLocaleString() + ' — Success'
        : '—';
      document.getElementById('lastRunText').textContent = lastRunText;
    } catch (err) {
      console.error(err);
      document.getElementById('lastRunText').textContent = '—';
    }
  }

  // ETL trigger
  document.getElementById('runLoadBtn').addEventListener('click', async () => {
    const btn = document.getElementById('runLoadBtn');
    btn.disabled = true;
    const prevText = btn.textContent;
    btn.textContent = 'Running...';
    try {
      const res = await fetch('/load');
      const text = await (res.headers.get('content-type') || '').includes('application/json') 
        ? await res.json() 
        : await res.text();
      console.log('/load response', text);

      setTimeout(() => {
        updateLastETLRun();
        renderCharts();
      }, 1400);
    } catch (err) {
      console.error('Error calling /load', err);
      document.getElementById('lastRunText').textContent = '— Error';
    } finally {
      btn.disabled = false;
      btn.textContent = prevText;
    }
  });

  // initial render
  updateLastETLRun(); // populate last ETL run
  renderCharts();
  setInterval(renderCharts, 5 * 60 * 1000);
</script>


</body>
</html>
